From f72d4d9c1ad2bde054f4c04470ace2072b8c61ed Mon Sep 17 00:00:00 2001
From: 4m8 <4m@I.oN>
Date: Wed, 6 Jan 2016 16:16:47 +0100
Subject: fix stagefright vulnerability

Change-Id: If3a08448ba634376084d74f2880552feceedcd11
---
 media/libstagefright/ESDS.cpp           |   6 ++
 media/libstagefright/MPEG4Extractor.cpp | 103 ++++++++++++++++++++++++++++++--
 media/libstagefright/SampleTable.cpp    |  39 ++++++++++--
 3 files changed, 138 insertions(+), 10 deletions(-)

diff --git a/media/libstagefright/ESDS.cpp b/media/libstagefright/ESDS.cpp
index 4a0c35c..c76bc4a 100644
--- a/media/libstagefright/ESDS.cpp
+++ b/media/libstagefright/ESDS.cpp
@@ -136,6 +136,8 @@ status_t ESDS::parseESDescriptor(size_t offset, size_t size) {
     --size;
 
     if (streamDependenceFlag) {
+        if (size < 2)
+            return ERROR_MALFORMED;
         offset += 2;
         size -= 2;
     }
@@ -145,11 +147,15 @@ status_t ESDS::parseESDescriptor(size_t offset, size_t size) {
             return ERROR_MALFORMED;
         }
         unsigned URLlength = mData[offset];
+        if (URLlength >= size)
+            return ERROR_MALFORMED;
         offset += URLlength + 1;
         size -= URLlength + 1;
     }
 
     if (OCRstreamFlag) {
+        if (size < 2)
+            return ERROR_MALFORMED;
         offset += 2;
         size -= 2;
 
diff --git a/media/libstagefright/MPEG4Extractor.cpp b/media/libstagefright/MPEG4Extractor.cpp
index 7ea2902..fbca22f 100644
--- a/media/libstagefright/MPEG4Extractor.cpp
+++ b/media/libstagefright/MPEG4Extractor.cpp
@@ -723,6 +723,8 @@ status_t MPEG4Extractor::parseChunk(off64_t *offset, int depth) {
                         mDataSource = cachedSource;
                     }
                 }
+                if (!mLastTrack)
+                    return ERROR_MALFORMED;
 
                 mLastTrack->sampleTable = new SampleTable(mDataSource);
             }
@@ -814,6 +816,9 @@ status_t MPEG4Extractor::parseChunk(off64_t *offset, int depth) {
                 return ERROR_MALFORMED;
             }
 
+            if (!mLastTrack)
+                return ERROR_MALFORMED;
+
             uint8_t version;
             if (mDataSource->readAt(data_offset, &version, 1) < 1){
                 return ERROR_IO;
@@ -905,6 +910,9 @@ status_t MPEG4Extractor::parseChunk(off64_t *offset, int depth) {
                 return ERROR_MALFORMED;
             }
 
+            if (!mLastTrack)
+                return ERROR_MALFORMED;
+
             uint8_t version;
             if (mDataSource->readAt(
                         data_offset, &version, sizeof(version))
@@ -948,11 +956,12 @@ status_t MPEG4Extractor::parseChunk(off64_t *offset, int depth) {
                 }
                 duration = ntohl(duration32);
             }
-            mLastTrack->meta->setInt64(
-                    kKeyDuration, (duration * 1000000) / mLastTrack->timescale);
+            if (duration != 0 && mLastTrack->timescale != 0) {
+                mLastTrack->meta->setInt64(kKeyDuration, (duration * 1000000) / mLastTrack->timescale);
+            }
 #ifdef QCOM_HARDWARE
             int64_t timeUs = 0;
-            if (mLastTrack->meta->findInt64( kKeyEditOffset, &timeUs))
+            if (duration != 0 && mLastTrack->timescale != 0 && mLastTrack->meta->findInt64( kKeyEditOffset, &timeUs))
             {
                 mLastTrack->meta->setInt64(kKeyDuration,(duration * 1000000) / mLastTrack->timescale + timeUs);
             }
@@ -1017,6 +1026,10 @@ status_t MPEG4Extractor::parseChunk(off64_t *offset, int depth) {
                 // multiple text display formats. These formats will be used to
                 // display the timed text.
                 const char *mime;
+
+                if (!mLastTrack)
+                    return ERROR_MALFORMED;
+
                 CHECK(mLastTrack->meta->findCString(kKeyMIMEType, &mime));
                 if (strcasecmp(mime, MEDIA_MIMETYPE_TEXT_3GPP)) {
                     // For now we only support a single type of media per track.
@@ -1084,6 +1097,9 @@ status_t MPEG4Extractor::parseChunk(off64_t *offset, int depth) {
                    chunk, num_channels, sample_size, sample_rate);
 #endif
 
+            if (!mLastTrack)
+                return ERROR_MALFORMED;
+
             mLastTrack->meta->setCString(kKeyMIMEType, FourCC2MIME(chunk_type));
             mLastTrack->meta->setInt32(kKeyChannelCount, num_channels);
             mLastTrack->meta->setInt32(kKeySampleRate, sample_rate);
@@ -1142,6 +1158,9 @@ status_t MPEG4Extractor::parseChunk(off64_t *offset, int depth) {
             // printf("*** coding='%s' width=%d height=%d\n",
             //        chunk, width, height);
 
+            if (!mLastTrack)
+                return ERROR_MALFORMED;
+
             mLastTrack->meta->setCString(kKeyMIMEType, FourCC2MIME(chunk_type));
             mLastTrack->meta->setInt32(kKeyWidth, width);
             mLastTrack->meta->setInt32(kKeyHeight, height);
@@ -1164,6 +1183,10 @@ status_t MPEG4Extractor::parseChunk(off64_t *offset, int depth) {
         case FOURCC('s', 't', 'c', 'o'):
         case FOURCC('c', 'o', '6', '4'):
         {
+
+            if (!mLastTrack || !mLastTrack->sampleTable.get())
+                return ERROR_MALFORMED;
+
             status_t err =
                 mLastTrack->sampleTable->setChunkOffsetParams(
                         chunk_type, data_offset, chunk_data_size);
@@ -1178,6 +1201,10 @@ status_t MPEG4Extractor::parseChunk(off64_t *offset, int depth) {
 
         case FOURCC('s', 't', 's', 'c'):
         {
+
+            if (!mLastTrack || !mLastTrack->sampleTable.get())
+                return ERROR_MALFORMED;
+
             status_t err =
                 mLastTrack->sampleTable->setSampleToChunkParams(
                         data_offset, chunk_data_size);
@@ -1193,6 +1220,10 @@ status_t MPEG4Extractor::parseChunk(off64_t *offset, int depth) {
         case FOURCC('s', 't', 's', 'z'):
         case FOURCC('s', 't', 'z', '2'):
         {
+
+            if (!mLastTrack || !mLastTrack->sampleTable.get())
+                return ERROR_MALFORMED;
+
             status_t err =
                 mLastTrack->sampleTable->setSampleSizeParams(
                         chunk_type, data_offset, chunk_data_size);
@@ -1212,6 +1243,10 @@ status_t MPEG4Extractor::parseChunk(off64_t *offset, int depth) {
             // each fragment originally prefixed with a 2 byte length will
             // have a 4 byte header (0x00 0x00 0x00 0x01) after conversion,
             // and thus will grow by 2 bytes per fragment.
+
+            if (!mLastTrack)
+                return ERROR_MALFORMED;
+
             mLastTrack->meta->setInt32(kKeyMaxInputSize, max_size + 10 * 2);
             *offset += chunk_size;
 
@@ -1235,6 +1270,10 @@ status_t MPEG4Extractor::parseChunk(off64_t *offset, int depth) {
 
         case FOURCC('s', 't', 't', 's'):
         {
+
+            if (!mLastTrack || !mLastTrack->sampleTable.get())
+                return ERROR_MALFORMED;
+
             status_t err =
                 mLastTrack->sampleTable->setTimeToSampleParams(
                         data_offset, chunk_data_size);
@@ -1249,6 +1288,10 @@ status_t MPEG4Extractor::parseChunk(off64_t *offset, int depth) {
 
         case FOURCC('c', 't', 't', 's'):
         {
+
+            if (!mLastTrack || !mLastTrack->sampleTable.get())
+                return ERROR_MALFORMED;
+
             status_t err =
                 mLastTrack->sampleTable->setCompositionTimeToSampleParams(
                         data_offset, chunk_data_size);
@@ -1263,6 +1306,10 @@ status_t MPEG4Extractor::parseChunk(off64_t *offset, int depth) {
 
         case FOURCC('s', 't', 's', 's'):
         {
+
+            if (!mLastTrack || !mLastTrack->sampleTable.get())
+                return ERROR_MALFORMED;
+
             status_t err =
                 mLastTrack->sampleTable->setSyncSampleParams(
                         data_offset, chunk_data_size);
@@ -1331,6 +1378,9 @@ status_t MPEG4Extractor::parseChunk(off64_t *offset, int depth) {
                 return ERROR_MALFORMED;
             }
 
+            if (!mLastTrack)
+                return ERROR_MALFORMED;
+
             mLastTrack->meta->setData(
                     kKeyESDS, kTypeESDS, &buffer[4], chunk_data_size - 4);
 
@@ -1365,6 +1415,9 @@ status_t MPEG4Extractor::parseChunk(off64_t *offset, int depth) {
                 return ERROR_IO;
             }
 
+            if (!mLastTrack)
+                return ERROR_MALFORMED;
+
             mLastTrack->meta->setData(
                     kKeyAVCC, kTypeAVCC, buffer, chunk_data_size);
 
@@ -1398,6 +1451,9 @@ status_t MPEG4Extractor::parseChunk(off64_t *offset, int depth) {
                 return ERROR_IO;
             }
 
+            if (!mLastTrack)
+                return ERROR_MALFORMED;
+
             mLastTrack->meta->setData(kKeyD263, kTypeD263, buffer, chunk_data_size);
 
             *offset += chunk_size;
@@ -1538,6 +1594,9 @@ status_t MPEG4Extractor::parseChunk(off64_t *offset, int depth) {
                 return ERROR_IO;
             }
 
+            if (!mLastTrack)
+                return ERROR_MALFORMED;
+
             uint32_t type = ntohl(buffer);
             // For the 3GPP file format, the handler-type within the 'hdlr' box
             // shall be 'text'. We also want to support 'sbtl' handler type
@@ -1552,6 +1611,10 @@ status_t MPEG4Extractor::parseChunk(off64_t *offset, int depth) {
 
         case FOURCC('t', 'x', '3', 'g'):
         {
+
+            if (!mLastTrack)
+                return ERROR_MALFORMED;
+
             uint32_t type;
             const void *data;
             size_t size = 0;
@@ -1562,6 +1625,10 @@ status_t MPEG4Extractor::parseChunk(off64_t *offset, int depth) {
 
             uint8_t *buffer = new uint8_t[size + chunk_size];
 
+            if ((chunk_size > SIZE_MAX) || (SIZE_MAX - chunk_size <= size)) {
+                return ERROR_MALFORMED;
+            }
+
             if (size > 0) {
                 memcpy(buffer, data, size);
             }
@@ -1588,6 +1655,9 @@ status_t MPEG4Extractor::parseChunk(off64_t *offset, int depth) {
             if (mFileMetaData != NULL) {
                 ALOGV("chunk_data_size = %lld and data_offset = %lld",
                         chunk_data_size, data_offset);
+
+               if (chunk_data_size >= SIZE_MAX - 1)
+                    return ERROR_MALFORMED;
                 uint8_t *buffer = new uint8_t[chunk_data_size + 1];
                 if (mDataSource->readAt(
                     data_offset, buffer, chunk_data_size) != (ssize_t)chunk_data_size) {
@@ -1597,6 +1667,10 @@ status_t MPEG4Extractor::parseChunk(off64_t *offset, int depth) {
                     return ERROR_IO;
                 }
                 const int kSkipBytesOfDataBox = 16;
+
+                if (chunk_data_size <= kSkipBytesOfDataBox)
+                    return ERROR_MALFORMED;
+
                 mFileMetaData->setData(
                     kKeyAlbumArt, MetaData::TYPE_NONE,
                     buffer + kSkipBytesOfDataBox, chunk_data_size - kSkipBytesOfDataBox);
@@ -1666,6 +1740,9 @@ status_t MPEG4Extractor::parseTrackHeader(
         duration = U32_AT(&buffer[20]);
     }
 
+    if (!mLastTrack)
+        return ERROR_MALFORMED;
+
     mLastTrack->meta->setInt32(kKeyTrackID, id);
 
     size_t matrixOffset = dynSize + 16;
@@ -1715,11 +1792,11 @@ status_t MPEG4Extractor::parseTrackHeader(
 }
 
 status_t MPEG4Extractor::parseMetaData(off64_t offset, size_t size) {
-    if (size < 4) {
+    if (size < 4 || size == SIZE_MAX) {
         return ERROR_MALFORMED;
     }
 
-    uint8_t *buffer = new uint8_t[size + 1];
+    uint8_t *buffer = new (std::nothrow) uint8_t[size + 1];
     if (mDataSource->readAt(
                 offset, buffer, size) != (ssize_t)size) {
         delete[] buffer;
@@ -1833,6 +1910,9 @@ status_t MPEG4Extractor::parseMetaData(off64_t offset, size_t size) {
                 int32_t delay, padding;
                 if (sscanf(mLastCommentData,
                            " %*x %x %x %*x", &delay, &padding) == 2) {
+                    if (!mLastTrack)
+                        return ERROR_MALFORMED;
+
                     mLastTrack->meta->setInt32(kKeyEncoderDelay, delay);
                     mLastTrack->meta->setInt32(kKeyEncoderPadding, padding);
                 }
@@ -1952,12 +2032,18 @@ status_t MPEG4Extractor::updateAudioTrackInfoFromESDS_MPEG4Audio(
 #ifdef QCOM_HARDWARE
     if (objectTypeIndication == 0xA0) {
         // This isn't MPEG4 audio at all, it's EVRC
+        if (!mLastTrack)
+            return ERROR_MALFORMED;
+
        mLastTrack->meta->setCString(kKeyMIMEType, MEDIA_MIMETYPE_AUDIO_EVRC);
        return OK;
     }
 #endif
     if (objectTypeIndication == 0xe1) {
         // This isn't MPEG4 audio at all, it's QCELP 14k...
+        if (!mLastTrack)
+            return ERROR_MALFORMED;
+
         mLastTrack->meta->setCString(kKeyMIMEType, MEDIA_MIMETYPE_AUDIO_QCELP);
         return OK;
     }
@@ -1970,6 +2056,10 @@ status_t MPEG4Extractor::updateAudioTrackInfoFromESDS_MPEG4Audio(
         ALOGE("MP3 track in MP4/3GPP file is not supported");
         return ERROR_UNSUPPORTED;
 #endif
+
+        if (!mLastTrack)
+            return ERROR_MALFORMED;
+
         mLastTrack->meta->setCString(kKeyMIMEType, MEDIA_MIMETYPE_AUDIO_MPEG);
         return OK;
     }
@@ -2033,6 +2123,9 @@ status_t MPEG4Extractor::updateAudioTrackInfoFromESDS_MPEG4Audio(
         return ERROR_UNSUPPORTED;
     }
 
+    if (!mLastTrack)
+        return ERROR_MALFORMED;
+
     int32_t prevSampleRate;
     CHECK(mLastTrack->meta->findInt32(kKeySampleRate, &prevSampleRate));
 
diff --git a/media/libstagefright/SampleTable.cpp b/media/libstagefright/SampleTable.cpp
index e49a6d8..784168f 100644
--- a/media/libstagefright/SampleTable.cpp
+++ b/media/libstagefright/SampleTable.cpp
@@ -231,8 +231,13 @@ status_t SampleTable::setSampleToChunkParams(
         return ERROR_MALFORMED;
     }
 
+    if (SIZE_MAX / sizeof(SampleToChunkEntry) <= mNumSampleToChunkOffsets)
+        return ERROR_OUT_OF_RANGE;
+
     mSampleToChunkEntries =
-        new SampleToChunkEntry[mNumSampleToChunkOffsets];
+        new (std::nothrow) SampleToChunkEntry[mNumSampleToChunkOffsets];
+    if (!mSampleToChunkEntries)
+        return ERROR_OUT_OF_RANGE;
 
     for (uint32_t i = 0; i < mNumSampleToChunkOffsets; ++i) {
         uint8_t buffer[12];
@@ -343,7 +348,14 @@ status_t SampleTable::setTimeToSampleParams(
     }
 
     mTimeToSampleCount = U32_AT(&header[4]);
-    mTimeToSample = new uint32_t[mTimeToSampleCount * 2];
+    uint64_t allocSize = mTimeToSampleCount * 2 * (uint64_t)sizeof(uint32_t);
+    if (allocSize > SIZE_MAX) {
+        return ERROR_OUT_OF_RANGE;
+    }
+
+    mTimeToSample = new (std::nothrow) uint32_t[mTimeToSampleCount * 2];
+    if (!mTimeToSample)
+        return ERROR_OUT_OF_RANGE;
 
     size_t size = sizeof(uint32_t) * mTimeToSampleCount * 2;
     if (mDataSource->readAt(
@@ -386,7 +398,14 @@ status_t SampleTable::setCompositionTimeToSampleParams(
     }
 
     mNumCompositionTimeDeltaEntries = numEntries;
-    mCompositionTimeDeltaEntries = new uint32_t[2 * numEntries];
+    uint64_t allocSize = numEntries * 2 * (uint64_t)sizeof(uint32_t);
+    if (allocSize > SIZE_MAX) {
+        return ERROR_OUT_OF_RANGE;
+    }
+
+    mCompositionTimeDeltaEntries = new (std::nothrow) uint32_t[2 * numEntries];
+    if (!mCompositionTimeDeltaEntries)
+        return ERROR_OUT_OF_RANGE;
 
     if (mDataSource->readAt(
                 data_offset + 8, mCompositionTimeDeltaEntries, numEntries * 8)
@@ -431,7 +450,15 @@ status_t SampleTable::setSyncSampleParams(off64_t data_offset, size_t data_size)
         ALOGV("Table of sync samples is empty or has only a single entry!");
     }
 
-    mSyncSamples = new uint32_t[mNumSyncSamples];
+    uint64_t allocSize = mNumSyncSamples * (uint64_t)sizeof(uint32_t);
+    if (allocSize > SIZE_MAX) {
+        return ERROR_OUT_OF_RANGE;
+    }
+
+    mSyncSamples = new (std::nothrow) uint32_t[mNumSyncSamples];
+    if (!mSyncSamples)
+        return ERROR_OUT_OF_RANGE;
+
     size_t size = mNumSyncSamples * sizeof(uint32_t);
     if (mDataSource->readAt(mSyncSampleOffset + 8, mSyncSamples, size)
             != (ssize_t)size) {
@@ -503,7 +530,9 @@ void SampleTable::buildSampleEntriesTable() {
         return;
     }
 
-    mSampleTimeEntries = new SampleTimeEntry[mNumSampleSizes];
+    mSampleTimeEntries = new (std::nothrow) SampleTimeEntry[mNumSampleSizes];
+    if (!mSampleTimeEntries)
+        return;
 
     uint32_t sampleIndex = 0;
     uint64_t sampleTime = 0;
-- 
2.5.0

